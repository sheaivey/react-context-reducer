{"version":3,"file":"prod.js","sources":["../src/core/core.js","../src/core/contextDecorator.js","../src/core/withContextProviders.js","../src/core/useContexts.js","../src/core/connectContexts.js","../src/contextReducer/combineReducers.js","../src/contextReducer/ReduxDevToolsMiddleWare.js","../src/contextReducer/createContextReducer.js"],"sourcesContent":["import { msg, warning } from '../utils/logging';\n\n// global react-context-reducer contexts\nconst registeredContexts = {};\n\nexport const registerContext = (decoratedContext) => {\n  if (process.env.NODE_ENV !== 'production') {\n    if (registeredContexts[decoratedContext.contextKey]) {\n      throw new Error(msg(`A decoratedContext already exists with the supplied contextKey \"${decoratedContext.contextKey}\".`));\n    }\n\n    const requiredKeys = ['contextKey', 'Context', 'Provider', 'use'];\n    const missingKeys = [];\n    requiredKeys.forEach((key) => {\n      if (!decoratedContext[key]) {\n        missingKeys.push(key);\n      }\n    });\n    if (missingKeys.length) {\n      throw new Error(msg(`The provided decoratedContext did not supply the following properties \"${missingKeys.join('\", \"')}\". Did you forget to use \"contextDecorator(contextKey, Context, Provider, extra)\"?`));\n    }\n  }\n  registeredContexts[decoratedContext.contextKey] = decoratedContext;\n};\n\nexport const removeContext = (contextKey) => {\n  if (process.env.NODE_ENV !== 'production') {\n    if (!registeredContexts[contextKey]) {\n      warning(`The contextKey \"${contextKey}\" could not be removed because it does not exist.`);\n    }\n  }\n  delete registeredContexts[contextKey];\n};\n\nexport const getContext = (contextKey) => {\n  if (process.env.NODE_ENV !== 'production') {\n    if (!registeredContexts[contextKey]) {\n      throw new Error(msg(`The contextKey \"${contextKey}\" has not yet been added. Be sure your context store has been added with \"registerContext(...)\" before trying to use it. `));\n    }\n  }\n  return registeredContexts[contextKey];\n};\n\nexport const getContexts = (contextKeys) => {\n  if (!contextKeys) {\n    // return all registered decoratedContexts\n    return registeredContexts;\n  }\n  // only get the requested decoratedContexts\n  const stores = {};\n  contextKeys.forEach((contextKey) => {\n    stores[contextKey] = getContext(contextKey);\n  });\n  return stores;\n};\n","import React, { useContext } from 'react';\nimport { msg } from '../utils/logging';\nimport { getContext } from './core';\n\nconst contextDecorator = (contextKey, Context, Provider, extra = {}) => {\n  return {\n    ...extra,\n    contextKey: contextKey,\n    Context: Context,\n    connect: (\n      mapStoreToProps = () => {}\n    ) => (WrappedComponent) => {\n      return props => {\n        const value = getContext(contextKey).use();\n        return (\n          <WrappedComponent\n            {...mapStoreToProps(value, props)}\n          />\n        );\n      };\n    },\n    use: () => {\n      const value = useContext(Context);\n      if (process.env.NODE_ENV !== 'production') {\n        if (!value) {\n          throw new Error(msg(`The contextKey \"${contextKey}\" has not been provided for consumption. Be sure to wrap your app with the HOC \"withContextProviders()(App)\" before trying to consume a context.`));\n        }\n      }\n      return value;\n    },\n    Provider: Provider\n  };\n};\n\nexport default contextDecorator;\n","import React from 'react';\nimport { getContext, getContexts } from './core';\n\n// recursively wraps a component with all provided contextKeys.\nconst recursiveProvider = (WrappedComponent, contextKeys) => {\n  if (contextKeys.length === 0) {\n    return (props) => (<WrappedComponent {...props} />);\n  }\n  const contextKey = contextKeys.pop();\n  const Provider = getContext(contextKey).Provider;\n  const Component = recursiveProvider(WrappedComponent, contextKeys);\n  return (props) => (\n    <Provider>\n      <Component {...props} />\n    </Provider>\n  );\n};\n\nconst withContextStoreProviders = (contextKeys) => (WrappedComponent) => {\n  return recursiveProvider(WrappedComponent, contextKeys || Object.keys(getContexts()));\n};\n\nexport default withContextStoreProviders;\n","import { getContext } from './core';\nimport { msg } from '../utils/logging';\n\nexport const useContext = (contextKey) => {\n  return getContext(contextKey).use();\n};\n\nconst useContexts = (contextKeys) => {\n  if (process.env.NODE_ENV !== 'production') {\n    if (!Array.isArray(contextKeys)) {\n      throw new Error(msg(`You must provide an array of contextKeys to use.`));\n    }\n    if (contextKeys.length === 0) {\n      throw new Error(msg(`You must provide at least one contextKey to use.`));\n    }\n  }\n  const stores = [];\n  contextKeys.forEach((contextKey) => {\n    const value = useContext(contextKey);\n    stores.push(value);\n  });\n  return stores;\n};\n\nexport default useContexts;\n","import React from 'react';\nimport { getContext } from './core';\nimport { msg } from '../utils/logging';\n\nconst connectContexts = (\n  contextKeys = [],\n  mapContextStoreToProps = () => ({})\n) => (WrappedComponent) => {\n  return props => {\n    if (process.env.NODE_ENV !== 'production') {\n      if (!Array.isArray(contextKeys)) {\n        throw new Error(msg(`You must provide an array of contextKeys to connect.`));\n      }\n      if (contextKeys.length === 0) {\n        throw new Error(msg(`You must provide at least one contextKey to connect.`));\n      }\n    }\n    const stores = [];\n    contextKeys.forEach((contextKey) => {\n      const value = getContext(contextKey).use();\n      stores.push(value);\n    });\n    return (\n      <WrappedComponent\n        {...mapContextStoreToProps(stores, props)}\n      />\n    );\n  };\n};\n\nexport default connectContexts;\n","import { warning, msg } from '../utils/logging';\n\n// modified combineReducers from Redux: https://github.com/reduxjs/redux/blob/master/src/combineReducers.js\nconst combineReducers = (reducers) => {\n  const reducerKeys = Object.keys(reducers);\n  const finalReducers = {};\n  for (let i = 0; i < reducerKeys.length; i++) {\n    const key = reducerKeys[i];\n    if (process.env.NODE_ENV !== 'production') {\n      if (typeof reducers[key] === 'undefined') {\n        warning(`No reducer provided for key \"${key}\"`);\n      }\n    }\n    if (typeof reducers[key] === 'function') {\n      finalReducers[key] = reducers[key];\n    } else {\n      if (process.env.NODE_ENV !== 'production') {\n        warning(`The reducer provided for key \"${key}\" is not a function.`);\n      }\n    }\n  }\n  const finalReducerKeys = Object.keys(finalReducers);\n\n  return function combination(state = {}, action) {\n    let hasChanged = false;\n    const nextState = {};\n    for (let i = 0; i < finalReducerKeys.length; i++) {\n      const key = finalReducerKeys[i];\n      const reducer = finalReducers[key];\n      const previousStateForKey = state[key];\n      const nextStateForKey = reducer(previousStateForKey, action);\n      if (process.env.NODE_ENV !== 'production') {\n        if (typeof nextStateForKey === 'undefined') {\n          throw new Error(msg('reducers should always return a state other then \"undefined\"'));\n        }\n      }\n      nextState[key] = nextStateForKey;\n      hasChanged = hasChanged || nextStateForKey !== previousStateForKey;\n    }\n    return hasChanged ? nextState : state;\n  };\n};\n\nexport default combineReducers;\n","const reduxDevToolsActions = {\n  ReplaceState: '@@REPLACE_STATE'\n};\n\nconst defaultConfig = {\n  features: {\n    dispatch: true,\n    persist: false,\n    reorder: false,\n    skip: true,\n    jump: true,\n    import: false,\n    export: false,\n    test: false\n  }\n};\n\nexport default (store, reducer, options = {}) => {\n  if (window.__REDUX_DEVTOOLS_EXTENSION__) {\n    const extension = window.__REDUX_DEVTOOLS_EXTENSION__.connect({ ...defaultConfig, ...options });\n    extension.init(store.getState());\n    extension.subscribe((message, extra) => {\n      if (message.type === 'DISPATCH' && message.payload) {\n        switch (message.payload.type) {\n          case 'TOGGLE_ACTION':\n          case 'JUMP_TO_ACTION':\n          case 'JUMP_TO_STATE':\n            // replaying global state\n            const state = JSON.parse(message.state);\n            store.dispatch({ type: reduxDevToolsActions.ReplaceState, data: state });\n        }\n      }\n    });\n    return (state, action) => {\n      const nextState = action.type === reduxDevToolsActions.ReplaceState ? action.data : reducer(state, action);\n      if (action.type === reduxDevToolsActions.ReplaceState) {\n        return nextState; // dont do anything\n      }\n      extension.send(action, nextState);\n      return nextState; // dont do anything\n    };\n  }\n  return (state, action) => {\n    const nextState = reducer(state, action);\n    console.log(`Action Triggered: ${action.type} [${options.name || ''}]`, action);\n    return nextState;\n  };\n};\n","import React, { createContext, useReducer } from 'react';\nimport PropTypes from 'prop-types';\nimport { contextDecorator } from '../core';\nimport { msg } from '../utils/logging';\n\nimport reduxDevToolsMiddleware from './ReduxDevToolsMiddleWare';\n\nconst createContextReducer = (contextKey, reducer, middlewares = false) => {\n  const Context = createContext();\n  const initialState = reducer(undefined, { type: '@@INIT' }); // returns initialState\n  const WrappedContext = contextDecorator(\n    contextKey,\n    Context,\n    (props) => {},\n    {\n      getInitialState: () => initialState,\n      getState: () => initialState, // overloaded\n      dispatch: (action) => {\n        if (process.env.NODE_ENV !== 'production') {\n          throw new Error(msg(`The contextKey \"${contextKey}\" has not been provided for consumption. Be sure to wrap your app with the HOC \"withContextProviders()(App)\" before trying to consume a context.`));\n        }\n      } // overloaded\n    }\n  );\n\n  let enhancedReducer = reduxDevToolsMiddleware(\n    {\n      getState: WrappedContext.getState,\n      dispatch: (action) => WrappedContext.dispatch(action)\n    },\n    reducer,\n    { // reduxDevTools options\n      name: contextKey\n    }\n  );\n\n  WrappedContext.Provider = (props) => { /* Provider HoC */\n    const value = useReducerStore(WrappedContext, enhancedReducer, initialState, middlewares);\n    return (\n      <Context.Provider value={value}>\n        {props.children}\n      </Context.Provider>\n    );\n  };\n  WrappedContext.Provider.propTypes = {\n    children: PropTypes.any\n  };\n  return WrappedContext;\n};\n\nexport default createContextReducer;\n\nconst useReducerStore = (WrappedContext, reducer, initialState, middlewares) => {\n  // TODO: this function gets called over and over rebuilding middleware and updating .getState() .dispatch()\n  const [state, dispatch] = useReducer(reducer, initialState);\n\n  let enhancedDispatch = dispatch;\n  if (middlewares && Array.isArray(middlewares) && middlewares.length) {\n    const middlewareAPI = {\n      getState: () => state,\n      dispatch: action => dispatch(action)\n    };\n    const chain = middlewares.map(middleware => middleware(middlewareAPI));\n    enhancedDispatch = compose(...chain)(dispatch);\n  }\n\n  const finalDispatch = (action) => enhancedDispatch(action);\n  // experimental Reducer Store API\n  WrappedContext.getState = () => state;\n  WrappedContext.dispatch = (action) => enhancedDispatch(action);\n  return [ state, finalDispatch ];\n};\n\nconst compose = (...funcs) => x =>\n  funcs.reduceRight((composed, f) => f(composed), x);\n"],"names":["registeredContexts","registerContext","decoratedContext","contextKey","getContext","getContexts","contextKeys","stores","forEach","contextDecorator","Context","Provider","connect","mapStoreToProps","WrappedComponent","props","value","use","React","useContext","recursiveProvider","length","pop","Component","withContextStoreProviders","Object","keys","useContexts","push","connectContexts","mapContextStoreToProps","combineReducers","reducers","reducerKeys","finalReducers","i","key","finalReducerKeys","state","action","hasChanged","nextState","reducer","previousStateForKey","nextStateForKey","reduxDevToolsActions","ReplaceState","defaultConfig","features","dispatch","persist","reorder","skip","jump","test","store","options","window","__REDUX_DEVTOOLS_EXTENSION__","extension","init","getState","subscribe","message","extra","type","payload","JSON","parse","data","send","console","log","name","createContextReducer","middlewares","createContext","initialState","undefined","WrappedContext","getInitialState","enhancedReducer","reduxDevToolsMiddleware","useReducerStore","children","propTypes","PropTypes","any","useReducer","enhancedDispatch","Array","isArray","middlewareAPI","chain","map","middleware","compose","funcs","x","reduceRight","composed","f"],"mappings":"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"}